# DirecTV RC66RX Remote Control

![DirecTV RC66RX](directv_rc66rx.jpg)

[DirecTV RC66RX FCC Info](https://fccid.io/MG33013)

## Contents
* [Description](#description)
* [Signal](#signal)
* [Row Format](#row-format)
* [Row Interpretation](#row-interpretation)
* [Button Code Mapping](#button-code-mapping)
* [Example](#example)
* [Sample Library](#sample-library)

## Description ##

This signal format is generated by DirecTV remote controllers such as the
RC64RB, RC65RX, and RC66RX.  Samples in the collection were generated by the
RC66RX.

This series of remote controllers features both IR and RF modes.  The "R" after
the number refers to remote's ability to transmit DirecTV functions in RF mode.
There are models such as the RC66X which do NOT have the ability to operate in
RF mode.

These devices also feature a selector switch for discrete DirecTV/AV1/AV2/TV
operation and the ability to program those AV1/AV2/TV positions so that the
device will transmit IR signals compatible with many other manufacturer/model
devices.

In RF mode, this series of remotes operate near 433.92 MHz. Newer DirecTV
remotes, such as the RC73, operate in the 2425 MHz - 2475 MHz range and may use
a different protocol.

In RF mode, these remotes are believed to work with DirecTV receiver models such
as the R16, H20, H21, HR21, R22, H22, HR22, H23, HR23, H24, HR24, H25, H34,
HR34, and C31. It is believed that this remote will not work in RF mode with the
C41, HR44, HR54 or D12 model receivers.  This information is not verified and
may be inaccurate.

The DirecTV RF (and IR) modes of this remote may be programmed with a six-digit
Device ID. This is meant to pair the remote with a specific DirecTV receiver
(based on the last six digits of the receiver's serial number), but any six-
digit code is valid and this code is then transmitted as part of the signal.

By default, the remote control operates in IR mode. To put the remote control into RF mode:

1. Make sure slider on top is set to the left (DTV mode)
2. Press and hold MUTE & SELECT, wait for two blinks, release
3. Press 9 6 1
4. Press CHANNEL UP (CHANNEL DOWN would put the remote in IR mode)
5. Press any 6 digit code to be used as the Device ID number (sent with every signal)
6. Press SELECT

## Signal ##

Each button press on the remote sends an FSK signal centered near 433.92 MHz
with mark and space frequencies +/- 50 kHz from center.  Raw bits are about 600
μs in length.

Each button press on the device sends out complete repetitions of the data as
rows for as long as the button is held down.  It is possible that the row is
only sent once if the button press is extremely brief.

The row is repeated for as long as the button is held down, each repetition
separated by 46 bits of gap silence (46 * 600μs = 27,600μs).  Upon release of
the button on the remote, the signal completes any row it is currently sending
and stops transmitting.

For each button press on the remote, the very first row in the signal sent can
be determined in its series of repetitions by its use of a Long SYNC pattern.
Repetitions of the row for that button press use a Short SYNC.  A general sense
of how long the button was held can be determined by counting the repetitions of
the row in the signal.

The exception to this is the `[SELECT]` button.  It sends rows with the code for
`[SELECT]` as expected, but upon this button's release, the device sends a
single row with a Long SYNC and the <code>[SELECT&nbsp;RELEASE]</code> button
ID.

## Row Format ##

Signals contain one or more rows, each separated by a gap. Row format is SYNC +
DATA + EOR.

There are two types of SYNC bursts used, a "short" SYNC and a "long" SYNC.

A Short SYNC is 3 raw space bits + 5 raw mark bits + 2 raw space bits
(`0001111100`). However, the very first row in the group of repetitions uses a
Long SYNC: 3 space bits + 10 mark bits + 2 space bits (`000111111111100`).

DATA is of variable raw bit length, but will always decode to 40 bits of logical
data. The encoding method is a bit unusual. DATA may be deliniated at each
transition from a space bit to a mark bit to yeild raw data units.  These data
units are either 2, 3, or 4 bits in length.

After 20 data units, there is a single unit of 1 raw mark bit followed by 3 raw
space bits ('1000') to signify the End Of Row (EOR).

| Unit of Raw Bits | Decoded Logical Data Bits |
|------------------|---------------------------|
| `10`   | `00` |
| `100`  | `01` |
| `110`  | `10` |
| `1100` | `11` |
| `1000` | `EOR` |

## Row Interpretation ##

Once decoded, the 40 bits of data may be interpreted as 10 nibbles (0-9):

`MM DD DD DB BC`

| Nibble # | Letter | Description |
|----------|--------|-------------|
| 0 - 1    | MM     | Model? Seems to always be 0x10 |
| 2 - 6    | DDDDD  | Device ID. 0x00000 - 0xF423F are valid (000000 - 999999 in decimal) |
| 7 - 8    | BB     | Button Code. 0x00 - 0xFF maps to specific buttons or functions |
| 9        | C      | Checksum. Least Significant Nibble of sum of previous 9 nibbles, 0x0 - 0xF |

## Button Code Mapping ##

Here's what I've been able to determine:

<details><summary>Click to show or hide button code mapping</summary>
<p>

Button codes span an entire logical byte of data, but decoding these codes to
button labels/meanings is likely incomplete.  RF signals are sent when the
remote has its selector switch in DirecTV mode (leftmost position), but RF
signals are sometimes sent when the remote is not in DirecTV mode (i.e., the
selector switch is in AV1, AV2, or TV positions) under certain conditions.

| Button Code | Description |
|-------------|-------------|
| 0x00 |  |
| 0x01 | [1] |
| 0x02 | [2] |
| 0x03 | [3] |
| 0x04 | [4] |
| 0x05 | [5] |
| 0x06 | [6] |
| 0x07 | [7] |
| 0x08 | [8] |
| 0x09 | [9] |
| 0x0A |  |
| 0x0B |  |
| 0x0C |  |
| 0x0D | [CH UP] |
| 0x0E | [CH DOWN] |
| 0x0F | [CH PREV] |
| 0x10 | [PWR] |
| 0x11 | [0] |
| 0x12 | [DASH] |
| 0x13 | [ENTER] |
| 0x14 - 0x1F |  |
| 0x20 | [MENU] |
| 0x21 | [UP] |
| 0x22 | [DOWN] |
| 0x23 | [LEFT] |
| 0x24 | [RIGHT] |
| 0x25 | [SELECT] |
| 0x26 | [EXIT] |
| 0x27 | [BACK] |
| 0x28 | [GUIDE] |
| 0x29 | [ACTIVE] |
| 0x2A | [LIST] |
| 0x2B |  |
| 0x2C |  |
| 0x2D |  |
| 0x2E | [INFO] |
| 0x2F |  |
| 0x30 | [VCR PLAY] |
| 0x31 | [VCR STOP] |
| 0x32 | [VCR PAUSE] |
| 0x33 | [VCR RWD] |
| 0x34 | [VCR FFD] |
| 0x35 | [VCR REC] |
| 0x36 | [VCR BACK] |
| 0x37 | [VCR SKIP] |
| 0x38 - 0x40 |  |
| 0x41 | [RED] |
| 0x42 | [YELLOW] |
| 0x43 | [GREEN] |
| 0x44 | [BLUE] |
| 0x45 - 0x4F |  |
| 0x50 |  |
| 0x51 | [TV: VCR {all} and just switched from other input - maybe alert to switch to other mode?] <sup>[3](#fn1)</sup> |
| 0x52 - 0x59 |  |
| 0x5A | [AV1/AV2/TV: FORMAT,PWR,VCR {all}, EXIT, U/D/L/R/SEL, MENU, CH U/D/PREV, 0-9/DASH/ENTER] <sup>[1](#fn1)</sup> |
| 0x5B | [DTV&TV POWER ON/OFF], [TV INPUT], [VOLUME UP/DOWN/MUTE] <sup>[1](#fn1)</sup> |
| 0x5C | [AV1/AV2/TV: TV INPUT, DTV&TV POWER ON/OFF, VOL U/D/M - maybe alert that no TV IR Programmed?] <sup>[1](#fn1)</sup> |
| 0x5D | [TV:  GUIDE, ACTIVE, LIST, BACK, INFO, R/G/Y/B] <sup>[1](#fn1)</sup> |
| 0x5E | [AV1: GUIDE, ACTIVE, LIST, BACK, INFO, R/G/Y/B] <sup>[1](#fn1)</sup> |
| 0x5F | [AV2: GUIDE, ACTIVE, LIST, BACK, INFO, R/G/Y/B] <sup>[1](#fn1)</sup> |
| 0x60 - 0x6F |  |
| 0x70 - 0x72 |  |
| 0x73 | [FORMAT] |
| 0x74 - 0x7F |  |
| 0x80 | [DTV: DTV&TV POWER ON] <sup>[2](#fn1)</sup> |
| 0x81 | [DTV: DTV&TV POWER OFF] <sup>[2](#fn1)</sup> |
| 0x82 - 0x8F |  |
| 0x90 - 0x9F |  |
| 0xA0 - 0xAF |  |
| 0xB0 - 0xBF |  |
| 0xC0 - 0xCF |  |
| 0xD0 - 0xD5 |  |
| 0xD6 | [SELECT RELEASE] <sup>[4](#fn1)</sup> |
| 0xD7 - 0xDF |  |
| 0xE0 - 0xEF |  |
| 0xF0 - 0xFF |  |

<a name="fn1">[1]</a> If none of the AV1/AV2/TV switch configurations are
programmed with a Mfg/Model Device IR code.

<a name="fn1">[2]</a> If any of AV1/AV2/TV switch configurations are programmed
with a Mfg/Model Device IR code, DTV: DTV&TV ON/OFF send separate codes and the
TV Input button no longer sends an RF code

<a name="fn1">[3]</a> If any of the VCR control buttons have been pressed in any
of the DTV/AV1/AV2 switch settings, then switched to the IR programmed TV
setting, and then any of the VCR control buttons pressed, the device sends this
code the first (and only the first) time a VCR control button is pressed in that
mode.

<a name="fn1">[4]</a> Sent once with a long SYNC when the select button is
released.

</p>
</details>

## Example ##

For this example, the remote has been programmed with device ID "123456" using
the method detailed in a previous section.  The sample file
[`01/g004_433.92M_250k.cu8`](01/g004_433.92M_250k.cu8) was captured with
`rtl_433 -g 20 -S all` when the <code>[VCR&nbsp;PLAY]</code> button on the
remote was pressed.

Using `rtl_433` with the flex spec, here is the data in the signal:

`rtl_433 -r g004_433.92M_250k.cu8 -X n=DirecTV,m=FSK_PCM,s=600,l=600,r=2400`

![DirecTV g004 flex spec](directv_g004_flex_spec.png)

Let's focus on the first row in that signal, `{70}1ff94aa66b4aacad20`.
Here's what this looks like in binary:

`0001111111111001010010101010011001101011010010101010110010101101001000`

Here's a representation of that part of the signal (as seen in
[URH](https://github.com/jopohl/urh)):

![DirecTV g004 signal rep1](directv_g004_signal_rep1.png)

The first part of that signal row, `000111111111100`, is a Long SYNC.  Because
there are 10 (instead of 5) raw mark bits, this row would be the first (or only)
repetition sent for this button press on the remote.

Next, the raw DATA bits,
`1010010101010011001101011010010101010110010101101001000` can be split into its
20 raw data units and its End Of Row unit at each transition from space to mark
bits:

<code>10 100 10 10 10 100 1100 110 10 110 100 10 10 10 10 1100 10 10 110 100 1000</code>

Decoding these raw data units into their logical bits, we get:

<code>00&nbsp;&nbsp;01&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;01&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;10&nbsp;00&nbsp;&nbsp;10&nbsp;&nbsp;01&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;11&nbsp;00&nbsp;00&nbsp;&nbsp;10&nbsp;&nbsp;01&nbsp;&nbsp;EOR</code>

Taking those 40 bits and representing as hex, we get:

`0x101e240309`

We can break this apart into the Model `0x10`, Device ID `0x1e240`, Button ID
`0x30`, and Checksum `0x9`.

Model `0x10` is correct, Device ID `0x1e240` in decimal is `123456`, and Button
ID `0x30` corresponds to the <code>[VCR&nbsp;PLAY]</code> button label.

The sum of the first 9 nibbles `0x1 + 0x0 + 0x1 + 0xe + 0x2 + 0x4 + 0x0 + 0x3 +
0x0` = `0x19` and the least signficant nibble of that total, `0x9`, matches the
Checksum nibble.

Furthermore, we see that there were 5 repetitions of the row, so we can get an
idea of how long the button was held down.

## Sample Library

| .cu8 Sample | Raw Data | Logical Data | Device ID / Button ID / Button Name|
|------------|----------|--------------|----------------|
| [01/g001_433.92M_250k.cu8](01/g001_433.92M_250k.cu8) | `{64}1ff94aaaaaab49a8`, `{59}1f2955555569350` × 4, `{66}1ff94aaaaaac934a0` | `0x1000000258` × 5, `0x1000000d64` | `000000` / `0x25` × 5, `0xd6` / `[SELECT]` × 5, <code>[SELECT&nbsp;RELEASE]</code> |
| [01/g002_433.92M_250k.cu8](01/g002_433.92M_250k.cu8) | `{65}1ff94aaaaaab4a640`, `{60}1f29555555694c8` × 3 | `0x1000000247` × 4 | `000000` / `0x24` / `[RIGHT]` |
| [01/g003_433.92M_250k.cu8](01/g003_433.92M_250k.cu8) | `{63}1ff94aaaaaab5250`, `{58}1f295555556a4a0` × 26 | `0x1000000214` × 27 | `000000` / `0x21` / `[UP]` |
| [01/g004_433.92M_250k.cu8](01/g004_433.92M_250k.cu8) | `{70}1ff94aa66b4aacad20`, `{65}1f2954cd695595a40` × 4 | `0x101e240309` × 5 | `123456` / `0x30` / <code>[VCR&nbsp;PLAY]</code> |

